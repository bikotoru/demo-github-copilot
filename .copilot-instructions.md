# Copilot Instructions - AI Chat Application

## Project Overview

This is a full-stack real-time chat application that enables users to have conversations with an AI assistant powered by Google's Gemini AI. The project consists of a Python FastAPI backend and a Next.js frontend with modern UI components.

## Architecture

### Backend (`/backend/`)
- **Framework**: FastAPI with Python
- **AI Integration**: Google Gemini 2.0 Flash model
- **Key Features**:
  - REST API with streaming support
  - CORS enabled for frontend communication
  - Real-time streaming responses using Server-Sent Events (SSE)
  - Conversation history management
  - Health check endpoints

### Frontend (`/frontend/`)
- **Framework**: Next.js 15 with React 19
- **UI Library**: ShadCN UI with Radix UI components
- **Styling**: Tailwind CSS with dark/light theme support
- **Key Features**:
  - Real-time chat interface with streaming responses
  - Dark/light mode toggle
  - Responsive design
  - TypeScript for type safety

## Key Files and Components

### Backend Files
- `main.py` - Main FastAPI application with chat endpoints
- `requirements.txt` - Python dependencies
- `.env` - Environment variables (GEMINI_API_KEY required)

### Frontend Files
- `app/layout.tsx` - Root layout with theme provider
- `app/page.tsx` - Main page rendering the chat component
- `components/chat.tsx` - Main chat component with streaming functionality
- `providers/theme-provider.tsx` - Theme management using next-themes
- `components/ui/` - ShadCN UI components library

## API Endpoints

### Backend Endpoints
- `GET /` - Root endpoint returning API status
- `GET /health` - Health check endpoint
- `GET /test-gemini` - Test Gemini AI connection
- `POST /chat` - Standard chat endpoint (non-streaming)
- `POST /chat/stream` - Streaming chat endpoint for real-time responses

### Request/Response Format
```typescript
// Request body for /chat/stream
{
  "message": "User message",
  "conversation_history": [
    {
      "user": "Previous user message",
      "assistant": "Previous AI response"
    }
  ]
}

// Streaming response format
data: {"content": "partial response", "done": false}
data: {"content": "", "done": true}
```

## Development Setup

### Backend Setup
1. Install dependencies: `pip install -r requirements.txt`
2. Create `.env` file with `GEMINI_API_KEY=your_api_key`
3. Run server: `python main.py` (localhost:8000)

### Frontend Setup
1. Install dependencies: `npm install` or `bun install`
2. Run development server: `npm run dev` (localhost:3000)
3. Build for production: `npm run build`

## Key Features Implementation

### Real-time Streaming
- Frontend uses fetch API with ReadableStream to consume SSE
- Backend yields streaming responses using FastAPI's StreamingResponse
- Progressive message building with typing indicators

### Theme Management
- Global theme provider wrapping the entire application
- Automatic system theme detection
- Persistent theme selection across sessions
- Smooth transitions between themes

### UI/UX Features
- Auto-scroll to latest messages
- Loading states and typing indicators
- Message timestamps
- User/AI avatar differentiation
- Responsive design for mobile/desktop

## Environment Variables

### Backend
- `GEMINI_API_KEY` - Required Google Gemini API key

### Frontend
- No environment variables required for basic functionality
- Theme persistence handled by next-themes

## Dependencies

### Backend Key Dependencies
- `fastapi` - Web framework
- `google-generativeai` - Gemini AI SDK
- `python-dotenv` - Environment variable management
- `uvicorn` - ASGI server

### Frontend Key Dependencies
- `next` - React framework
- `react` - UI library
- `next-themes` - Theme management
- `@radix-ui/*` - Headless UI components
- `tailwindcss` - CSS framework
- `lucide-react` - Icon library

## Coding Patterns

### Component Structure
- Functional components with TypeScript
- Custom hooks for theme management
- ShadCN UI component pattern with cn() utility
- Proper error handling and loading states

### API Integration
- Async/await pattern for API calls
- Streaming response handling with ReadableStream
- Error boundary implementation
- Type-safe request/response interfaces

## Security Considerations
- CORS properly configured for development
- API key stored in environment variables
- Input validation on both frontend and backend
- No sensitive data exposed in client-side code

## Performance Optimizations
- Streaming responses for better user experience
- Efficient re-rendering with proper React keys
- Auto-scroll optimization
- Debounced user inputs where applicable